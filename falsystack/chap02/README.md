# 2장 문자열 계산기 구현을 통한 테스트와 리팩토링

- 테스트는 한 번에 메소드 하나에만 집중해야 한다.
- JUnit은 매 테스트마다 인스턴스를 새로 생성해주는것을 선호한다.
    - 상태 값이 변경되어 다음 테스트에 영향을 주는것을 방지하기 위함이다.
```java
class CalculatorTest {
  private Calculator calc;

  @BeforeEach
  void beforeEach() {
    calc = new Calculator();
  } 
}
```

`String.isEmpty()`
- 문자열의 길이가 0인 경우 `true`를 반환한다.
- 나머지는 `false`

### 리팩토링

소스코드를 구현했으면 반드시 뒤 따라야 하는 과정이 중복을 제거하고, 읽기 좋은 코드를 구현하기 위해 구조를 변경하는 **리팩토링**이다.
리팩토링이란 소스코드의 가독성을 높이고 유지보수를 편하게 하기 위해 소스코드의 구조를 변경하는 것을 의미한다.

리팩토링에 대한 감이 안잡힌다면 밑의 3가지를 중점적으로 지켜보자.
- 메소드가 한 가지 책임만 가지도록 구현한다.
- 인덴트 깊이를 1단계로 유지한다.
- else를 사용하지 마라.

리팩토링을 한 후 주의 깊게 봐야 할 부분은 `private`으로 분리한 메소드가 아니라 
`pbulic`으로 공개하고 있는 메소드가 얼마나 읽기 쉽고, 좋은가가 가장 중요하다.

세부 구현에 집중하도록 하지 않고 논리적인 로직을 쉽게 파악할 수 있도록 구현하는 것이 읽기 좋은 코드이다.
우리는 깔끔하고 읽기 좋은 코드를 구현하기 위해 끊임 없이 고민하고 연습해야 한다.

메소드를 잘 분리해 놓으면 새로운 요구사항이 발생할 경우 해당 메소드를 찾아 해당 메소드만 수정사항을 반영하는 것이 가능하다.

### TDD

요구사항에 대한 테스트 케이스를 작성 -> 테스트 실패 -> 테스트케이스를 성공시킬 구현 코드를 작성 -> 테스트 성공

> 분기가 많은 코드는 지저분한 코드이다.(좋지 못한 코드이다.)

### 정규식
`Matcher`와 `Pattern`클래스를 이용한 정규식 패턴을 만들어 사용하기
```java
class Sample {
  void sample() {
    Matcher m = Pattern.compile("//(.)\n(.*)").matcher(text);
    if (m.find()) {
      String customDelimiter = m.group(1);
      String[] tokens = m.group(2).split(customeDelimeter);
    }
  }
}
```

## 2장 정리
- 계속해서 관심을 가지고 리팩토링 하고 싶은 코드로 만들자
- 테스트와 리팩토링은 분리할 수 없는 동반자 관계이고 같이 연습해야 한다.
- 안정적으로 리팩토링을 하려면 반드시 경고한 테스트가 뒷받침하고 있어야 한다.
- 리팩토링의 첫 번째 단계가 **프로덕션 코드에 대한 테스트 코드를 만드는 것**인 만큼 두 주제를 같이 학습해야 한다.